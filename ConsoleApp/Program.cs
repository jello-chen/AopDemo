using Mono.Cecil;
using Mono.Cecil.Cil;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace ConsoleApp
{
    class Program
    {
        static void Main(string[] args)
        {
            if(args.Length != 1)
            {
                Debug.WriteLine("Argument is invalid.");
                return;
            }
            var assemblyPath = args[0];
            Debug.WriteLine($"`{assemblyPath}` is handling...");
            var assembly = AssemblyDefinition.ReadAssembly(args[0]);
            var type = assembly.MainModule.GetTypes().FirstOrDefault(t => t.Name == "Class1");
            if (type != null)
            {
                var method = type.Methods.FirstOrDefault(m => m.Name == "Test");
                if (method != null)
                {

                    var firstInstruction = method.Body.Instructions.First();
                    var lastInstruction = method.Body.Instructions.Last();

                    // Check whether the method is asychronous.
                    // If yes, find the MoveNext method generated by compiler.
                    var isAsyncMethod = method.CustomAttributes.Any(m => m.AttributeType.FullName == "System.Runtime.CompilerServices.AsyncStateMachineAttribute");
                    if (isAsyncMethod)
                    {
                        var nestedType = type.NestedTypes.FirstOrDefault(t => t.Interfaces.Any(i => i.FullName == "System.Runtime.CompilerServices.IAsyncStateMachine"));
                        method = nestedType.Methods.FirstOrDefault(m => m.Name == "MoveNext");

                        firstInstruction = method.Body.Instructions.FirstOrDefault(i => i.OpCode == OpCodes.Nop);
                        var offset = method.Body.Instructions.Where(j => j.OpCode == OpCodes.Call && ((MethodReference)j.Operand).FullName == "System.Void System.Runtime.CompilerServices.TaskAwaiter::GetResult()").Last().Offset;
                        lastInstruction = method.Body.Instructions.FirstOrDefault(i => i.OpCode == OpCodes.Leave_S && i.Offset >= offset);
                    }

                    var il = method.Body.GetILProcessor();


                    // Build some method references
                    var mfBefore = assembly.MainModule.Import(
                        typeof(Console).GetMethod("WriteLine", new Type[] { typeof(string) }));
                    var mfLast = assembly.MainModule.Import(
                        typeof(Console).GetMethod("WriteLine", new Type[] { typeof(string) }));

                    // Insert instructions
                    var instruction = InsertBefore(il, firstInstruction, il.Create(OpCodes.Nop));
                    instruction = InsertBefore(il, firstInstruction, il.Create(OpCodes.Ldstr, "Before"));
                    instruction = InsertBefore(il, firstInstruction, il.Create(OpCodes.Call, mfBefore));
                    instruction = InsertBefore(il, lastInstruction, il.Create(OpCodes.Ldstr, "After"));
                    instruction = InsertBefore(il, lastInstruction, il.Create(OpCodes.Call, mfLast));
                    instruction = InsertBefore(il, lastInstruction, il.Create(OpCodes.Nop));

                    ComputeOffsets(method.Body);

                    if (isAsyncMethod)
                        method.Body.Instructions.FirstOrDefault(i => i.OpCode == OpCodes.Nop).Previous.Previous.Operand = method.Body.Instructions.FirstOrDefault(i => i.OpCode == OpCodes.Nop);

                    assembly.Write(assemblyPath);
                    Debug.WriteLine($"`{assemblyPath}` is handled.");
                }
            }
        }

        private static Instruction InsertBefore(ILProcessor worker, Instruction target, Instruction instruction)
        {
            worker.InsertBefore(target, instruction);
            return instruction;
        }

        private static Instruction InsertAfter(ILProcessor worker, Instruction target, Instruction instruction)
        {
            worker.InsertAfter(target, instruction);
            return instruction;
        }

        private static void ComputeOffsets(MethodBody body)
        {
            var offset = 0;
            foreach (var instruction in body.Instructions)
            {
                instruction.Offset = offset;
                offset += instruction.GetSize();
            }
        }
    }
}
